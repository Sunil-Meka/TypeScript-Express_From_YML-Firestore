"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCodegenAllOfSchema = void 0;
const types_1 = require("@openapi-generator-plus/types");
const _1 = require(".");
const stringify_1 = require("../../stringify");
const openapi_type_guards_1 = require("../../openapi-type-guards");
const examples_1 = require("../examples");
const external_docs_1 = require("../external-docs");
const utils_1 = require("../utils");
const vendor_extensions_1 = require("../vendor-extensions");
const discriminator_1 = require("./discriminator");
const interface_1 = require("./interface");
const naming_1 = require("./naming");
const object_absorb_1 = require("./object-absorb");
const utils_2 = require("./utils");
function toCodegenAllOfSchema(apiSchema, naming, state) {
    const strategy = state.generator.allOfStrategy();
    switch (strategy) {
        case types_1.CodegenAllOfStrategy.NATIVE:
            return toCodegenAllOfSchemaNative(apiSchema, naming, state);
        case types_1.CodegenAllOfStrategy.OBJECT:
        case types_1.CodegenAllOfStrategy.HIERARCHY:
            return toCodegenAllOfSchemaObject(apiSchema, naming, state);
    }
    throw new Error(`Unsupported allOf strategy: ${strategy}`);
}
exports.toCodegenAllOfSchema = toCodegenAllOfSchema;
function toCodegenAllOfSchemaNative(apiSchema, naming, state) {
    const { scopedName, scope } = naming;
    const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema);
    const nativeType = state.generator.toNativeObjectType({
        type: 'object',
        schemaType: types_1.CodegenSchemaType.ALLOF,
        scopedName,
        vendorExtensions,
    });
    let result = Object.assign(Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), (0, utils_2.extractCodegenSchemaCommon)(apiSchema, state)), { discriminator: null, discriminatorValues: null, polymorphic: false, vendorExtensions, externalDocs: (0, external_docs_1.toCodegenExternalDocs)(apiSchema), nativeType, type: 'allOf', format: null, schemaType: types_1.CodegenSchemaType.ALLOF, component: null, deprecated: false, examples: null, schemas: null, composes: [], implements: null });
    result.examples = (0, examples_1.toCodegenExamples)(apiSchema.example, undefined, undefined, result, state);
    if ((0, openapi_type_guards_1.isOpenAPIv3SchemaObject)(apiSchema, state.specVersion)) {
        result.deprecated = apiSchema.deprecated || false;
    }
    /* Must add model to knownSchemas here before we try to load other models to avoid infinite loop
       when a model references other models that in turn reference this model.
     */
    result = (0, utils_2.addToKnownSchemas)(apiSchema, result, naming, state);
    const allOf = apiSchema.allOf;
    for (const allOfApiSchema of allOf) {
        const allOfSchema = (0, _1.toCodegenSchemaUsage)(allOfApiSchema, state, {
            purpose: types_1.CodegenSchemaPurpose.GENERAL,
            required: false,
            suggestedScope: state.generator.nativeCompositionCanBeScope() ? result : scope,
            suggestedName: 'content',
            nameRequired: state.generator.nativeComposedSchemaRequiresName(),
        }).schema;
        if (!(0, types_1.isCodegenObjectSchema)(allOfSchema) && !(0, types_1.isCodegenInterfaceSchema)(allOfSchema) && !(0, types_1.isCodegenAllOfSchema)(allOfSchema)) {
            throw new Error(`allOf "${result.name}" references a non-object (${allOfSchema.schemaType}) schema: ${(0, stringify_1.debugStringify)(allOfApiSchema)}`);
        }
        result.composes.push(allOfSchema);
        (0, discriminator_1.addToAnyDiscriminators)(allOfSchema, result, state);
    }
    result.discriminator = (0, discriminator_1.toCodegenSchemaDiscriminator)(apiSchema, result, state);
    if (result.discriminator) {
        result.polymorphic = true;
    }
    (0, discriminator_1.loadDiscriminatorMappings)(result, state);
    return result;
}
var SchemaApproach;
(function (SchemaApproach) {
    SchemaApproach[SchemaApproach["PARENT"] = 0] = "PARENT";
    SchemaApproach[SchemaApproach["ABSORB"] = 1] = "ABSORB";
})(SchemaApproach || (SchemaApproach = {}));
function toCodegenAllOfSchemaObject(apiSchema, naming, state) {
    const { scopedName, scope } = naming;
    const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema);
    const nativeType = state.generator.toNativeObjectType({
        type: 'object',
        schemaType: types_1.CodegenSchemaType.OBJECT,
        scopedName,
        vendorExtensions,
    });
    let result = Object.assign(Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), (0, utils_2.extractCodegenSchemaCommon)(apiSchema, state)), { abstract: false, discriminator: null, discriminatorValues: null, polymorphic: false, vendorExtensions, externalDocs: (0, external_docs_1.toCodegenExternalDocs)(apiSchema), nativeType, type: 'object', format: null, schemaType: types_1.CodegenSchemaType.OBJECT, component: null, deprecated: false, additionalProperties: null, properties: null, examples: null, children: null, interface: null, implements: null, parents: null, schemas: null });
    result.examples = (0, examples_1.toCodegenExamples)(apiSchema.example, undefined, undefined, result, state);
    if ((0, openapi_type_guards_1.isOpenAPIv3SchemaObject)(apiSchema, state.specVersion)) {
        result.deprecated = apiSchema.deprecated || false;
    }
    /* Must add model to knownSchemas here before we try to load other models to avoid infinite loop
       when a model references other models that in turn reference this model.
     */
    result = (0, utils_2.addToKnownSchemas)(apiSchema, result, naming, state);
    /* Create a discriminator, if appropriate, removing the discriminator property from the schema's
    properties.
    */
    result.discriminator = (0, discriminator_1.toCodegenSchemaDiscriminator)(apiSchema, result, state);
    if (result.discriminator) {
        result.polymorphic = true;
    }
    /* Handle the reference schemas, either using inheritance or interface conformance */
    const allOf = apiSchema.allOf;
    for (const { apiSchema: allOfApiSchema, approach } of classifyAllOfSchemas(allOf, state)) {
        if (approach === SchemaApproach.PARENT) {
            const parentSchema = (0, _1.toCodegenSchemaUsage)(allOfApiSchema, state, {
                required: true,
                suggestedName: `${result.name}_parent`,
                purpose: types_1.CodegenSchemaPurpose.GENERAL,
                suggestedScope: scope,
            }).schema;
            if ((0, types_1.isCodegenObjectSchema)(parentSchema)) {
                (0, utils_2.addChildObjectSchema)(parentSchema, result);
            }
            else if ((0, types_1.isCodegenInterfaceSchema)(parentSchema)) {
                const parentImplementation = (0, interface_1.toCodegenInterfaceImplementationSchema)(parentSchema, { allowAbstract: true }, state);
                if (parentImplementation) {
                    (0, utils_2.addChildObjectSchema)(parentImplementation, result);
                }
                else {
                    /* If we can't create an implementation containing all of the parent's properties, we must absorb and have the properties ourselves */
                    (0, object_absorb_1.absorbCodegenSchema)(parentSchema, result);
                    (0, utils_2.addImplementor)(parentSchema, result);
                }
            }
            else {
                throw new Error(`allOf "${result.name}" references a non-object-like schema: ${parentSchema.schemaType}`);
            }
            /* Add discriminator values */
            (0, discriminator_1.addToAnyDiscriminators)(parentSchema, result, state);
        }
        else {
            /* We must absorb the schema from the others, and then indicate that we conform to them */
            const allOfSchema = (0, object_absorb_1.absorbApiSchema)(allOfApiSchema, result, scope, state);
            if (!allOfSchema) {
                continue;
            }
            /* Make sure there's an interface schema to use */
            const interfaceSchema = (0, types_1.isCodegenObjectSchema)(allOfSchema) || (0, types_1.isCodegenHierarchySchema)(allOfSchema) ? (0, interface_1.toCodegenInterfaceSchema)(allOfSchema, scope, state) : allOfSchema;
            if ((0, types_1.isCodegenInterfaceSchema)(interfaceSchema)) {
                (0, utils_2.addImplementor)(interfaceSchema, result);
            }
            (0, discriminator_1.addToAnyDiscriminators)(allOfSchema, result, state);
            if ((0, types_1.isCodegenHierarchySchema)(allOfSchema)) {
                /* Hierarchy schemas discover their members when we find them including the hierarchy in an allOf here */
                allOfSchema.composes.push(result);
            }
        }
    }
    (0, discriminator_1.loadDiscriminatorMappings)(result, state);
    return result;
}
/**
 * Classify each of the allOf schemas according to the approach that we should use to model them as object
 * relationships.
 * @param allOf the allOf schemas
 * @param state
 * @returns
 */
function classifyAllOfSchemas(allOf, state) {
    if (state.generator.supportsInheritance()) {
        /* An allOf does not imply hierarchy (https://swagger.io/specification/#composition-and-inheritance-polymorphism)
           but we still prefer to use parent/child relationships to reduce the duplication of code.
         */
        const referenceSchemas = allOf.filter(openapi_type_guards_1.isOpenAPIReferenceObject);
        if (referenceSchemas.length === 1 || state.generator.supportsMultipleInheritance()) {
            /* Use parent/child relationships */
            return allOf.map(apiSchema => ({
                apiSchema,
                approach: (0, openapi_type_guards_1.isOpenAPIReferenceObject)(apiSchema) ? SchemaApproach.PARENT : SchemaApproach.ABSORB,
            }));
        }
        /* A discriminator _does_ imply hierarchy (https://swagger.io/specification/#composition-and-inheritance-polymorphism)
           so if we can't use parent/child relationships above because there are too many possible parents, then we
           check if only one of those schemas is a discriminator hierarchy and we choose that as the parent.
         */
        const discriminatorSchemas = referenceSchemas.filter(schema => hasDiscriminator(schema, state));
        if (discriminatorSchemas.length === 1) {
            /* Use parent/child relationship with just the discriminator schema */
            return allOf.map(apiSchema => ({
                apiSchema,
                approach: apiSchema === discriminatorSchemas[0] ? SchemaApproach.PARENT : SchemaApproach.ABSORB,
            }));
        }
    }
    /* If we can't find any inheritance possibilties we just absorb all of the schemas */
    return allOf.map(apiSchema => ({
        apiSchema,
        approach: SchemaApproach.ABSORB,
    }));
}
function hasDiscriminator(apiSchema, state) {
    apiSchema = (0, utils_1.resolveReference)(apiSchema, state);
    if (apiSchema.discriminator) {
        return true;
    }
    if (apiSchema.allOf) {
        for (const allOfApiSchema of apiSchema.allOf) {
            if (hasDiscriminator(allOfApiSchema, state)) {
                return true;
            }
        }
    }
    return false;
}
